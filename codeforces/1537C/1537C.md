https://codeforces.com/contest/1537/problem/C
构造题
题目大意
你有 n 个各有高度的山峰，你需要重排山峰，使得第一个山峰和最后一个山峰的高度之差的绝对值最小。
此外，为了使游戏更加困难，并且上山总是比下山难，可以记游戏的困难程度为满足 $h_{i}<h_{i+1}$ 山的数量;
记山峰数组为h,长度为n

思路：
我们的目标就是
1. 在a中找到两个数的差的绝对值最小
2. 让 $h_{i}<h_{i+1}$ 的数量最多即使得后一位大于前一位的数最多，换句话就是使得数组出现递减的次数最少

很容易想到对数组排序
这样就能使得 $h_{i}<h_{i+1}$ 的数量最多
然后就是找到两个数的差的绝对值最小，这个遍历一遍就好了,假设我们已经找到了这俩个数，分别是h[k],h[l]且h[k]<=h[l];
如果我们直接将这两个数从数组中拿出来分别放在数组的左边和右边是不是就是答案了?A:不是，如果这么做你就会和我一样喜提红色大wa

那么怎样才是对的呢?
我们思考一下我们这么做为什么是错的:
考虑一个单调递增的函数h(x)，x的取值是 [a,b] 那么如果我们直接从[a,b]之间拿出来两个h(x)相近的数h[k],h[l]且h[k]<=h[l];
放在函数两端如果h[k]>h[a]那么会出现递减，如果h(b)>h[l]也会出现递减,那么就会出现且最多出现两次递减。
那么我们能做到只出现一次吗，可以的兄弟可以的我们只需要将下标小于等于k的数按顺序放在b的右边即可，即h[l],h[l+1],.....h[b],h[1]...h[k],这样做就只会出现一次递减且两个绝对差最小的在两边，

回顾一下我们一开始思考才不会错？
1. 多思考一下我们的答案是不是对的
2. 检查一下我们的数组的递减次数思考能不能找到更优的
3. 如果我们不移动h[k],h[l]移动其他数我们是不是就能找到答案了


