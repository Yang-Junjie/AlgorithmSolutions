# 题目大意
给你一个字符串s，由0和1组成，你有一个只能打0和1的打字机:
这个打字机有两个按钮，按钮0和按钮1
你需要通过这个打字机使用一根手指打印出这个字符串
1. 按下一次按钮算一步
2. 将手指从一个按钮移动到另一个按钮算一步，我们简称这一操作为切换(switch)
起初你的手指在按钮0上方
你可以选择字符串s的一个子串对这个子串进行反转，你最少需要多少步

# 思路
很容易想到以下子问题
1. 找到切换的次数
2. 反转哪个子串最好，反转子串能给我们带来什么
#### 问题一
这个问题还是很简单的我们遍历一次字符串当s[i]!=s[i+1]的时候就是我们需要进行一次切换操作

#### 问题二
这个问题是解决这个题的关键
我们随便找个样例分析：
$1101010010011011100 \rightarrow 1101111011001001000$

可以发现反转一个子串后会出现使得相同的数字连在一起,这样有什么好处？
好处就是能够使得我们切换的次数减少

上面分析情况，这使得我们的$switch - 2$

我们可以通过上方案例发现只要存在$...1...0...1...$的结构我们就一定能够反转某个子串使得$switch - 2$

Q:怎么发现的?
A:我们不用管字符串是怎么组成的，我们的目的是怎么减少switch，给你任意一个01串不管你怎么反转子串最大也只能让switch-2，因为最优的情况就是选择一个子串$S_{lr}=...01_l....0_r1....$反转变成$...00_r....1_l1....$或者$S_{lr}=...10_l....1_r0....$反转变成$...11_r....0_l0....$

Q:为什么不是$..0..1..0..$这种结构
A:举个反例如$010,switch=2$反转后变为$001,switch=1$即反转后使得$switch-1$
综上就是$...1...0...1...$的结构


最复杂的分析完了再分析特殊情况即不存在上述结构
$\sim$表示与前方后方一样的数字
1. $00\sim000\;switch=0$不需要反转
2. $11\sim 111\;switch = 1$ 不需要反转
3. $00\sim 01\sim11\;switch = 1$不需要反转
4. $11\sim 10\sim00\;switch = 2$反转一次能使得switch-1

**最后** 观察条件规律：
1. 当switch>2则通过反转一定可以switch-2
2. 当switch=2则通过反转一定可以switch-1
3. 当switch<2不需要反转则switch不变
```cpp
void solve()
{
    int n;
    string s;
    cin >> n >> s;
    s='0'+s;
    int cnt = 0;
    for (int i = 1; i <= n; i++) {
        if (s[i] != s[i - 1]) {
            cnt++;
        }
    }
    if(cnt==2){
        cnt--;
    }else if(cnt>2){
        cnt-=2;
    }
    cnt+=n;
    cout << cnt << endl;
}
```